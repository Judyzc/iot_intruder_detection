<!DOCTYPE html>
<html>
<head>

  <title>Room Detection Stacked Bar Graph</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: Arial; background: #f4f4f4; padding: 20px; }
    #myDiv { width: 80%; height: 400px; margin: auto; }
    .button-container {
        display: flex;
        justify-content: center;  
        gap: 20px;                 
        margin-top: 20px;
    }
    button {
        padding: 10px 25px;
        font-size: 16px;
        border: none;
        border-radius: 12px;       
        background-color: #007BFF; 
        color: white;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
    }

    button:hover {
        background-color: #0056b3; 
        transform: scale(1.05);    
    }

    button:active {
        transform: scale(0.98);   
    }
   
  </style>
</head>
<body>

<h1>Your Dashboard</h1>

<div>Welcome your iOT dashboard, where you can analyze real-time data from your device.</div>
<br />
<div id="device_status">Device Status: </div>
<br />
<div class="button-container">
    <button id="startBtn">Start Data Collection</button>
    <button id="stopBtn">Stop Data Collection</button>
</div>
<br />
<br />
<div id="info"></div>
<h2 style="text-align:center">Intruders and Registered Users Count </h2>
<div id="myDiv"></div>
<h2 style="text-align:center">Recognition Confidence</h2>
<div style="text-align:center">Confidence metrics are only reported for registered visitors. </div>
<br />
<div id="myDiv1"></div>
<h2 style="text-align:center">Confidence per Registered Face</h2>
<div id="myDiv3"></div>

<script>
  // x axis for the first graph, intruders and registered users stacked bar graph 
  let timeStamps = []; 
  // x axis for the second graph, showing average confidence over time 
  let timeStamps_confidences = []; 
  // total intruder and registered user count        
  let intrudersCounts = [];    
  let registeredCounts = []; 

  // average confidence values to be plotted in second graph
  let confidenceValues = []; 


  // intruder and visitor metrics during the entirety of data collection 
  let totalIntruders = 0;
  let totalRegistered = 0;

  // face id to average confidence for entirety of data collection 
  let faceConfidences = {};
 
  // Initializing the plots in Plotly 
  let data = [
    {
      x: timeStamps,
      y: intrudersCounts,
      name: 'Intruders',
      type: 'bar',
      marker: {color: 'red'}
    },
    {
      x: timeStamps,
      y: registeredCounts,
      name: 'Registered',
      type: 'bar',
      marker: {color: 'green'}
    }
  ];

  Plotly.newPlot('myDiv', data, {
    barmode: 'stack',
    title: 'Number of People Detected Every 5 minutes',
    xaxis: { title: 'Time' },
    yaxis: { title: 'Number of People', range: [0, 150] }
  });

  Plotly.newPlot("myDiv1", [
    { x: timeStamps_confidences, y: confidenceValues, mode: "lines+markers", name: "Avg Confidence" }
    ], {
    title: "Average Model Confidence Every 5 Minutes",
    xaxis: { title: "Time" },
    yaxis: { title: "Confidence (0-1)" }
    });
  
  Plotly.newPlot('myDiv3', [{
    x: [],
    y: [],
    type: 'bar',
    marker: { color: '#007BFF' }
  }], {
    title: 'Average Confidence per Registered Face',
    xaxis: { title: 'Face ID',  type: 'category' },
    yaxis: { title: 'Confidence', range: [0, 1] }
  })

  // Asynchronous function to retrieve the heartbeat status data from the server, this is a periodic function called every five minutes. 
  async function get_status() {
    try {
        const response = await fetch("http://54.167.124.79:5000/status");
        const data = await response.json();

       
        let device_status = false;

        
        data.forEach(entry => {
            if (entry.status) {
                device_status = true;
            }
        });

        return device_status;  
    } catch (error) {
        console.error("Error fetching status:", error);
        return false; 
    }
}

// Asynchronous function to update the UI with the information from the GET request
async function updateDeviceStatus() {
    const isAvailable = await get_status();

    const statusDiv = document.getElementById("device_status");
    if (isAvailable) {
        statusDiv.innerHTML = "Device Status: <strong style='color:green'>Available</strong>";
    } else {
        statusDiv.innerHTML = "Device Status: <strong style='color:red'>Unavailable</strong>";
    }
}


updateDeviceStatus();

// Periodically calling updateDeviceStatus function to update the UI and send a GET request every minute
setInterval(updateDeviceStatus, 60000);

  async function getCounts() {
    try {
         // Every five minutes, pull from the database server to count the number of intruders and registered visitors
        // that entered the room during a 5 minute interval. Each interval is independent from each other.
        const response = await fetch("http://54.167.124.79:5000/recent");
        const data = await response.json();

        var intruderCount = 0;
        var registeredCount = 0;
        let tempConfidences = [];
        let faceConfidences = {}
       
       
        data.forEach(entry => {
        if (entry.intruder_status === true) {
            intruderCount++;
            totalIntruders++;
        } else if (entry.intruder_status === false) {
            registeredCount++;
            totalRegistered++;
            // Storing data in two arrays - one array is for the entirety of the data collection period. The other array is for the five minute interval. We use the second array for the last plot. 
            if(entry.confidence>0.0){
              tempConfidences.push(entry.confidence);
              if(!faceConfidences[entry.face_id]) faceConfidences[entry.face_id] = [];
              faceConfidences[entry.face_id].push(entry.confidence);
            }
        }
        });

        return {
        intruderCount,
        registeredCount,
        tempConfidences,
        faceConfidences,
        };

    } catch (error) {
        console.error("Error fetching or counting:", error);

        return {
        intruderCount: 0,
        registeredCount: 0,
        tempConfidences: [],
        faceConfidences: {},
        };
    }
    }

  
  

   
  async function collectData() {

    let now = new Date();
    let timeStr = now.toLocaleTimeString(); 

    // Retrieving the data from the GET requests for the face ID -> confidence mapping, average confidences, registered/intruder count
    const {intruderCount, registeredCount, tempConfidences, faceConfidences} = await getCounts();
   
    timeStamps.push(timeStr);
    intrudersCounts.push(intruderCount);
    registeredCounts.push(registeredCount);
    Plotly.update('myDiv', {
      y: [intrudersCounts, registeredCounts],
      x: [timeStamps, timeStamps]
    });
    
    // We don't plot confidence when an intruder is detected, so sometimes this array tempConfidences could be empty
    if(tempConfidences.length>0){
        timeStamps_confidences.push(timeStr);
        //plotting the average confidences in a 5 minute interval
        const confidence_val = tempConfidences.reduce((sum, val) => sum + val, 0) / tempConfidences.length;
        confidenceValues.push(confidence_val);
        Plotly.update("myDiv1", {
            x: [timeStamps_confidences],
            y: [confidenceValues]
        });
    }
  
    // recalculating the averages for all of the ids in the dataset and then plotting them
    let avgConfidences = Object.keys(faceConfidences).map(id => {
        let vals = faceConfidences[id];
        let sum = vals.reduce((a,b) => a+b, 0);
        return { id, avg: sum / vals.length };
    });

    Plotly.update('myDiv3',
      {
        x: [avgConfidences.map(d => String(d.id))],
        y: [avgConfidences.map(d => d.avg)]
      },
      {
        xaxis: { type: 'category' }
      }
    );
    
    // Remove the first element in the plot or "shift" all the data to the left when we have exceeded 10 values in the x-axis
    if(timeStamps.length > 10) {
      timeStamps.shift();
      intrudersCounts.shift();
      registeredCounts.shift();
      confidenceValues.shift();
      
      Plotly.update('myDiv', {
        y: [intrudersCounts, registeredCounts],
        x: [timeStamps, timeStamps]
      });
      
    }
    if(timeStamps_confidences.length > 10) {
      timeStamps_confidences.shift();
      Plotly.update("myDiv1", {
            x: [timeStamps_confidences],
            y: [confidenceValues]
      });
    }

      // Updating UI with correct number of registered visitors and intruders
     document.getElementById("info").innerHTML = `
    <div>
        Intruders detected after data collection started: <strong>${totalIntruders}</strong>
    </div>
    <br />
    <div>
        Registered visitors detected after data collection started: <strong>${totalRegistered}</strong>
    </div>
    `;
  }


  let interval = null;
  // Starting data collection
  document.getElementById("startBtn").addEventListener("click", function() {
    if(interval !== null) return; 
    collectData();
    interval = setInterval(collectData, 300000);
  });

    // Clearing all of the data and plots when data collection is stopped
    document.getElementById("stopBtn").addEventListener("click", function() {
        if(interval !== null) {
            clearInterval(interval); 
            interval = null;         
            console.log("Data collection stopped.");
        }
        totalIntruders=0;
        totalRegistered=0;
         
        timeStamps = [];         
        intrudersCounts = [];    
        registeredCounts = []; 
        confidenceValues = []; 
        timeStamps_confidences = [];

        faceConfidences = {};
 
        tempConfidences = [];

        //Resetting all of the graphs
        Plotly.react('myDiv', [
          { x: [], y: [], name: 'Intruders', type: 'bar', marker: { color: 'red' } },
          { x: [], y: [], name: 'Registered', type: 'bar', marker: { color: 'green' } }
        ], {
          barmode: 'stack',
          title: 'Number of People Detected Every 5 minutes',
          xaxis: { title: 'Time' },
          yaxis: { title: 'Number of People', range: [0, 150] }
        });

        Plotly.react("myDiv1", [
          { x: [], y: [], mode: "lines+markers", name: "Avg Confidence" }
        ], {
          title: "Average Model Confidence Every 5 Minutes",
          xaxis: { title: "Time" },
          yaxis: { title: "Confidence (0-1)" }
        });

        Plotly.react('myDiv3', [{
          x: [],
          y: [],
          type: 'bar',
          marker: { color: '#007BFF' }
        }], {
          title: 'Average Confidence per Registered Face',
          xaxis: { title: 'Face ID', type: 'category' },
          yaxis: { title: 'Confidence', range: [0, 1] }
        });

        document.getElementById("info").innerHTML = `
    <div>
        Intruders detected after data collection started: <strong>0</strong>
    </div>
    <br />
    <div>
        Registered visitors detected after data collection started: <strong>0</strong>
    </div>
    `;

    });

  
</script>

</body>
</html>

